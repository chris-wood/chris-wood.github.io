---
layout: post
title: Channel and Object Encryption
---

TLDR: Object encryption is a significantly harder problem to solve correctly than
channel encryption. Moreover, it is often said that object encryption provides sufficient
"security" for CCN applications. But that's nonsense. Yes, it enables confidentiality.
But it does not enable privacy (according to today's definition). For this reason,
both channel and object encryption must be part of any viable network protocol
and the applications that it enables.

# Introduction

Have you ever been to [keylength.com](http://www.keylength.com/)? It's a pretty neat site that
gives you recommendations for the length of cryptographic keys depending on the lifetime
of the data. To give an example, according to the ECRYPT II recommentations from 2012, 
if you want "long-term protection," i.e., protection from 2016 to 2040, then you need 
at least 128 bits of security. This translates to a 128-bit symetric key, 3248-bit RSA key, 
and 256-bit ECC key. The reason I bring this up is that the longevity of keys and data
is an important concept that can often be the downfall of some security mechanism. An equally
important issue is how keys and data are managed. Much of security boils down to how well
secrets are chosen and how they are kept safe. In this post, I'll discuss these two issues
in the context of channel and object encryption. 

# Encryption Overview
Perhaps the single most important job of cryptography is to protect the communication (transfer,
movement, etc.) of data [1]. Schnieier describes data storage as a use case in which a data owner 
wishes to communicate data to themselves over time [2]. This perspective places secure data storage
on par with secure data transmission between two peers. This normalization is useful because
it allows us to consider the protection of data in transit and at rest using the same principles.

Encrypting data in transit and at rest are equivalent to channel and object encryption. 
Before describing the commonalities of these different techniques, I'll first review their
differences.

## Channel Encryption

Channel encryption keys are ephemeral and exist for the duration of the session. In the case
of TLS (1.3), the keys used to encrypt data in transit are *forward-secure* derived from long-term 
secret keys using a key exchange protocol such as Diffie Hellman. Forward secrecy is a property
which states that the compromise of these long-term keys does not compromise past session keys. 
This is achieved by having each session key derived from randomness generated by each party
in the protocol. Or, put another way, each party will generate new Diffie Hellman key shares
for each execution of the protocol. These key shares are never re-used and are never stored. 
If an attacker were to record the transcript of a key exchange protocol then they would never 
be able to recover the session key since neither private key shares are stored (and subject to
being compromised). 

## Object Encryption

Object encryption keys are not ephemeral -- they must last for at least as long as the data. 
Therefore, not only must the keys be chosen appropriately (i.e., have a suitable security level
depending on the sensitivity and longevitiy of the data), but the keys themselves must be protected
beyond use. It does not matter if data that will last 10 seconds is encrypted with a 256-bit key --
if the encryption key is compromised then data has also been compromised. In this case,
why bother encrypting the data at all? (I'm not advocating this approach, just
pointing out one conclusion to be derived from this effect.)

The key difference between object and channel encryption is that object encryption (encrypting at rest) 
requires state to be stored. That state is the key.

# Lifetime and Management Issues

The key to secure data encryption is proper key management. And in object 
encryption, it's not clear who controls the keys. Let's take AWS S3 as an
example. S3 buckets provide server-side encryption with server-generated and
managed keys as well as client-generated keys [3]. Regardless of who maintains the keys,
they must be secure from unauthorized access. The server and client are solving
the same problem of access control. And that's a classical security problem that dates
back to the early days of multi-user and multi-tenent operating systems.

Amazon uses their KMI (key management infrastructure) to protect and manage these keys.
The KMI is composed of a storage layer for plaintext keys and a management layer that
authorizes requests for these keys [4]. Keys are protected by a HSM (hardware-security module),
which is a special hardware component, typically comprised of a co-processor and tamper-resistant 
protections, for managing the lifecycle of cryptographic keys. (That's a discussion for another time.)
The internal design of the AWS KMI is beyod the scope of this little blog post. I'll
try to touch on that in the future.

# Final Thoughts

What does all of this mean? The cost, difficulty, and complexity required to implement proper
object encryption certainly exceeds that of channel encryption. Consider a TCP/IP application where a
channel is used to move arbitrary data from a server to a client (or vice versa). In this case, the benefit
of encrypting data at rest depends on the cost of losing that data (e.g., credit card or other PII information).
In CCN, where the server moves *specific data* to a client, the benefit of object encryption is 
that, with proper key management facilities, it can subsume channel encryption (*with respect to
confidentiality*). But what does this buy? Nothing, really, if we care about privacy,
since we'll always have to use channel encryption to attain (today's definition of) privacy.

# References

- [1] https://www.schneier.com/blog/archives/2010/06/data_at_rest_vs.html
- [2] B. Schneier. "Applied cryptography: protocols, algorithms, and source code in C." John Wiley & Sons, 2007.
- [3] http://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html
- [4] https://d0.awsstatic.com/whitepapers/aws-securing-data-at-rest-with-encryption.pdf

