---
layout: post
title: Anonymous Traffic Filtering
---

Anonymous traffic filtering is the problem of restricting traffic flow to only that
which is actually generated by a human (as opposed to a botnet). As an example use
case, this might be done by a CDN edge server providing traffic to clients behind a
Tor circuit [1]. Traditional CDN traffic monitoring techniques tend to flag packets
from Tor exit nodes as malicious. In response, they are served a CAPTCHA so that
the human can verify their presence and allow the traffic. Since these edge servers
are unable to distinguish human-generated traffic from otherwise malicious
traffic flowing from an exit node, Tor users are typically served many CAPTCHAs.
This leads to a bad user experience that discourages those users from using Tor.
In this document, we present a variety of mechanisms by which the CAPTCHA challenge
can be automatically bypassed to prevent user experience disruptions. In effect,
the illegitimate traffic is filtered from the CDN.

# Cryptographic Foundations

The schemes in this document depend on a variety of cryptographic techniques, including
(RSA) blind signatures and oblivious pseudorandom function (OPRF) protocols.

## Blind Signatures

A blind signature scheme is one in which a client can obtain the signature of a message m
from a server without the server learning m. The RSA blind signature scheme from Chaum works
roughly as follows. (Here, m is a message to be signed by a server and is assumed to be a
member of the RSA group. Also, the RSA modulus is N and the public and private keys
are e and d, respectively.)

1. Generate a random blinding element $$r$$ from the RSA group.
2. Compute $$m' = mr (mod\; N)$$
3. Send $$m'$$ to the server.
4. Sign $$m'$$ by computing $$s' = (m')^d (mod\; N)$$
5. Send $$s'$$ to the client.
6. Remove the blinding factor $$r$$ to obtain the original signature as $$s = (s')^(r^-1)$$.

By the properties of RSA, s is a valid signature for m.

## OPRFs in the Random Oracle Model

OPRFs are a special type of PRF in which two parties work to compute $$y = F(k, x)$$,
where $$k$$ is a key owned by the sender and $$x$$ is an input owned by the receiver. The goal
of an OPRF protocol is that the sender (server) learns nothing about the computation,
and the receiver learns y. (Hence the name, oblivious.) In the Random Oracle Model (ROM),
we may build an OPRF out of a blind signature scheme by simply hashing the resultant
signature [3]. That is, we may build the PRF as $$F(k, m) = H(SIG(k, m))$$, where $$SIG$$ is the
blind signature scheme and $$H$$ is a cryptographic hash function modeled as a random oracle.
According to [3], the OPRF itself unveils the blind signature *and* the actual OPRF output,
thereby allowing the receiver to remove its blind and yet still provide a valid OPRF value.
The protocol for this particular OPRF functionality works as follows.

1. Generate a random blinding element $$r$$ from the RSA group.
2. Compute $$m' = mr (mod N)$$.
3. Send $$m'$$ to the server.
4. Sign $$m'$$ by computing $$s' = (m')^d (mod N)$$.
5. Hash $$m'$$ to get $$y = F(k, m')$$.
6. Send $$s'$$ and $$y$$ to the client.
7. Remove the blinding factor on $$s'$$.

At the end, the client has a message $$m$$ and accompanying OPRF value $$y$$.

As a matter of technical correctness, this is not precisely an OPRF, since the server
learns the input and there is partial output other than the OPRF value. It
is an open problem to extend blind signature schemes, such as the RSA one due to
Chaum [2], to a secure computation $$F_{SIG}(k, m) \to (\perp, SIG(k, m))$$.

Another type of OPRF protocol was described recently by Hugo K. at RWC 2017 [4]. It
works as follows: $$s = F(k, m) = H(m)^{k}$$, where $$H$$ is a hash function that maps
its input to an element of a proper Diffie Hellman group and $$k$$ is a random exponent.
The protocol runs as follows:

1. The client computes $$H(m)^r$$ for some random value $$r$$ and sends the result to the server.
2. The server computes $$(H(m)^r)^k = H(m)^{rk}$$ and returns it to the client.
3. The client computes $$(H(m)^{rk})^{r^{-1}}$$, yielding $$H(m)^k$$.

By running this protocol, the client gets a signature $$s$$ over a random element in the group $$m$$.
One very useful property of this is that it can now be blinded at will. For example, assume the client
has $$m$$ and $$F(k, m) = H(m)^k$$. It can then compute $$H(m)^r$$ and $$(H(m)^k)^r = H(m)^{kr}$$.
If the client sends this tuple to the server, it can then remove the $$k$$ exponent by computing
$$(H(m)^{rk})^{k^{-1}} = H(m)^r$$ and check that this equals the message sent. If so, the client has
just proven that it is in possession of a message that was previously signed by the server, but it
has *no knowledge* about what message it was since it was signed. We call this sort of signature
*malleable*, or just randomizable.

# Blind Signatures to the Rescue

In this section we describe a series of approaches to the anonymous traffic
filtering problem based on blind signatures.

## One-Time Anonymous Tokens

In [1], the authors present a first approach towards solving this
problem that uses so-called one-time anonymous tokens to verify the human presence without
solving (more than one) CAPTCHA. The scheme works as follows. When the client is
first served a CAPTCHA, the solution is presented to the server along with $$T$$ blinded
tokens (RSA group elements). (Here, a blinded token is a blinded RSA group element.) Upon verifying the
CAPTCHA solution, the server will sign each of the $$TN$$ blinded tokens and return
the corresponding signatures to the client along with their desired resource.
Later, when the client is presented with another CAPTCHA, it will encrypt one
of its unblinded tokens and the corresponding signature under the server's (assumed
to be known) public key. The server can then verify the token and its signature
and, if it is deemed valid, return the desired content.

The main benefit of this design is that each token is unlinkable to the rest (assuming
each was originally generated at random). This prevents the server from linking same-origin
requests based on these tokens. Another benefit is that the server has complete control
over how many tokens can be delegated to a client. If it wants to limit the number of
bypasses per CAPTCHA to $$T'$$, it does so by only signing $$T' < T$$ tokens.

However, it requires $$O(T)$$ work for the server when generating token signatures and $$O(T)$$
state on the client. The former may be prohibitive whereas the latter is hardly a problem.

## Piggy-Backed Anonymous Tokens

An optimization on the anonymous tokens idea is to continually create them in a piggy-back
fashion instead of in a single batch request. When the client submits its CAPTCHA response,
it also submits a single blinded token to sign. If the CAPTCHA is valid, the server responds
with the appropriately blinded signature. Later, when that same token is redeemed, the client
submits another blinded token to be signed in the encrypted envelope. The server then
verifies the unblinded token's signature and, if valid, signs the new blinded token and replies
with the response. This variant incurs less overhead on the server since it signs at most
one token per CAPTCHA challenge. Moreover, this process can repeat indefinitely
so long as it is bootstrapped with
a human CAPTCHA solution. As a result, it permits an unlimited number of tokens for every single
CAPTCHA solution. This could potentially be abused if the CAPTCHA solution is stolen
or somehow forged. In contrast, the original solution permits at most $$T$$ tokens for every
CAPTCHA.

## Linkable Anonymous Tokens

Linkable anonymous tokens are a variant to the one-time anonymous token approach based
on Lamport's one-time password scheme. It works as follows. Instead of the client generating
N unique tokens to be signed in response to a CAPTCHA, the client generates a single
token and computes its $$T$$-th hash $$d$$, i.e., $$d = H^N(x)$$ for a
token (bit string) $$x$$. It then blinds this token
just as before. After verifying the CAPTCHA response, the server will then sign the blinded
digest and return the signature to the client. Later, when the client is prompted with the
first followup CAPTCHA, it provides the preimage of $$d$$ and the unblinded signature, both of which
are encrypted under the server's public key. The server receives the preimage, computes its
hash to produce $$d$$, and then verifies its signature. If it is valid, the server adds the preimage
to a cache of verified responses. Later, when the client receives the $$i$$-th CAPTCHA, it provides
the $$(N-i)$$-th preimage alone, encrypted under the server's public key. Upon receipt, the server
computes the hash of this preimage and checks to see if it has previously cached the value. If so,
the server caches the preimage and returns. Otherwise, the server signals to the client that its
token is invalid. This process can be done at most N times until the client can no longer generate
valid preimages.

The benefits of this approach are much faster verification at the server: it only requires one
hash computation and a cache lookup. However, the cache requires state at the server. Moreover,
the server can link preimages together to link these anonymous tokens together and associate
them with the same origin. (This effectively violates the unlinkable properties of client
traffic in Tor.) Also, the server no longer has control over the number of tokens that can be
delegated per CAPTCHA since $$N$$ is controlled by the client. This is an undesirable feature.

# Improvements with OPRFs

Let's now consider what we could do if we used OPRFs. As previously discussed, an OPRF lets two parties
jointly compute $$F(k, m)$$ while only one party learns the true OPRF value. The obvious application is
to assume that the server owns the secret key $$k$$ and the client provides the message $$m$$ to be signed.
Specifically, assume we use the one-round OPRF protocol from Hugo [4]. The server is assumed to have
a secret key it can use to compute the PRF and the client's secret input is a randomly chosen value.
The output of this protocol is, essentially, a MAC on the client's input, but one with the special randomizable
property described earlier. We can exploit this when clients need to redeem their tokens. Specifically,
they can simply blind $$H(m)$$ *and* the signature $$H(m)^k$$ with a fresh random value $$r$$ and send
both to the server. The server then verifies that removing the $$k$$ factor reveals the original value.

# Performance Considerations

The performance of these anonymous filtering schemes is determined by that of the underlying
primitive, i.e., an RSA blind signature or OPRF. Since the latter is easily portable to
elliptic curves, which benefit from less computation and memory overhead in comparison to
RSA public key systems, I'll focus on that going forward. To implement the OPRF scheme
from [4], we need a suitable curve, a function to hash onto the curve, and the ability
to do some basic arithmetic. (For simplicity, I'll skip the hash function part. I'm not
familiar with how this is generally done, so I'll just point to [5] as a temporary reference,
which has been in my queue for a long time now.) Luckily, Sage [6] provides all of this for us.
I implemented the basic malleable encryption scheme previously discussed using Curve25519
as the base for the arithmetic. The code for which is below. It shows how to generate
the initial token, blind it, sign (encrypt) it, unblind it, and then randomize it
as needed later on.

{% gist 841399b61e44ccf78c97281fbe6167cb %}

# References

- [1] [Protocol for bypassing challenge pages using RSA blind signed tokens.](https://github.com/cloudflare/challenge-bypass-specification)
- [2] [David Chaum. Blind signatures for untraceable payments. In CRYPTO, 1982.](http://blog.koehntopp.de/uploads/Chaum.BlindSigForPayment.1982.PDF)
- [3] [StanisÅ‚aw Jarecki and Xiaomin Liu, "Efficient oblivious pseudorandom function with applications to adaptive OT and secure computation of set intersection," Theory of Cryptography Conference, Springer Berlin Heidelberg, 2009.](https://pdfs.semanticscholar.org/e605/b71afc410051e6bd62f4e140ead0361b699f.pdf)
- [4] [Hugo Krawczyk, "Is Password InSecurity Inevitable? Cryptographic Enhancements to Password
Protocols", Real World Crypto 2017.](http://webee.technion.ac.il/~hugo/rwc17.pdf)
- [5] [Thomas Icart, "How to hash into elliptic curves," Advances in Cryptology-CRYPTO 2009, Springer Berlin Heidelberg, 2009, 303-316.](https://eprint.iacr.org/2009/226.pdf)
- [6] William A. Stein, "SageMath Software."
