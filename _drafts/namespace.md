---
layout: post
title: Naming is Hard
---

Naming seems to be a highly controversial and subjective topic lately.
This is particularly true in the area of "content-centric" or "named data" 
networking. Exactly what is the naming scheme used to assign meaning
to content? How do we discover and learn names? What do the names reveal
about the content to which it points? Are names absolute or relative in time?
I am greatly discouraged by the apparent readiness by which researchers
consider this to be a solved problem. These people will often say "name
the data" and "ask for the data with this name." But these simple answers
completely nearly ever one of the problems I just listed. In this post, 
I will attempt to make sense of the current state of the art of naming,
from an information science perspective, and discuss how we might be able
to do better for CCN and related architectures in which named data is a
first class citizen. 

# What's in a Name?

By and large, URIs are the standard way by which applications and users
identify data and services (i.e., resources) in the Internet. As the name
implies, a URI is something which identifies a resource. It can take two
forms -- URLs and URNs (links and names). A URL is an identifier in that
it specifies a way by which to access a resource. In this case, that access
strategy is encoded in a link. Conversely, a URN identifies a resource by 
referring to it by name in a particular namespace. The access mechanism
is not explicitly delineated in a URN. 

But URIs are not the only form of identifiers that we can exploit. Let's consider
some alternative networking architectures and their approaches to naming. 
URIs are primarily used to bind meaningful names to content in both IPv4 and 
IPv6 with DNS as the resolution service that translates between these names
and usable addresses. The GS1 (Global Language of Business) uses random
data and additional metadata to name products. SWE (Sensor Web Enablement)
uses unique identifiers based on random data to mark individual sensors.
Many ICN architectures like CCN and NDN use hierarchical URIs (URNs, really)
to mark data. Cryptographic hash digests are also used as static identifiers
for data. MobilityFirst, another future Internet architecture, uses GUIDs
and hash digests to mark data and entities in the network. 

Clearly, there is an underlying pattern amongst all of the options. 
To help develop a taxonomy for these naming schemes and conventions, Bauer 
et al. compiled a catalog of naming, addressing, and discovery schemes
useful or applicable to the IoT. And given the expected scale by which
data and devices will begin flooding the network, as well as the expectation
and anticipation for multi-homed or mobile entities, this report is immensely
useful when considering the naming problems that plague ICN. If you have 
the time to this paper I recommend you do so. If not, I will do my best to summarize
their findings here. 

## SUMMARY of that report

TODO

# What's are the Problems?

## Mobility

Identifiers or names act as bindings between some textual or otherwise 
simpler representation and some resource. Variable identifiers refer to
the underlying data they contain, (C-like) pointers identify a location
in memory whose contents may change over time, and web resource identifiers
point to some piece of data that can be accessed over the Internet. But 
there's a problem: URNs are good for identifying data within a namespace
while URLs are good for specifying how to get data. Web applications are 
drawn to URLs because they allow a browser to programmatically retrieve
the resource in question. Unfortunately, URLs have the nasty side effect
of binding a resource to a single location. For example, the URL

```
https://github.com/chris-wood
```

binds the content of my main page to the Github domain. Your browser will
use DNS to resolve the github name (within the com domain) to a specific
IP address and will then proceed to fetch the data in question from that
host. This is fine if my profile information stayed put at the host (or
behind the host). But what if the data was generated by something that was
mobile? What if the resource in question was a picture served by someone's 
mobile device? (Ignore the fact that addressing a user's mobile device is 
not great for now.) 

NDN and CCN adopt the idea of location-agnostic names. Specifically, 
the name of content (and thus the name of the request issued to get this
content) is named independently of where the data originates. Applications
are assigned a unique part of the global namespace under which to publish
their data, e.g., ```/twitter/```. These identifiers help mobile consumers
since their requests are still forwarded on a reverse-path basis [1]. Consumers
simply retransmit lost interests that failed to be delivered after as they 
moved. 

TODO: figure of mobility here (a consumer moving and then re-transmitting interests)

To deal with mobile producers, forwarder hints (locators) are provided to help the network
route requests to the actual location of the producer [1]. These locators are
said to be attainable through some resolution service such as DNS (or NDNS [2]),
which is used to help distribute forwarding hints and cryptographic keys. 
One way around these hint locators is if the network FIBs were continually
updated as data "anchors" (producers) moved throughout the network. This, however,
is problematic if many producers are mobile; routing signalling would consume
far too much bandwidth and the time to convergence would likely be slow. 

[1] Zhu, Zhenkai, Alexander Afanasyev, and Lixia Zhang. "A new perspective on mobility support." Named-Data Networking Project, Tech. Rep (2013).
[2] [https://github.com/named-data/ndns](https://github.com/named-data/ndns)

TODO: compare routing protocols here http://www.eng.auburn.edu/~szm0001/ccn2015/slides/CCN-Presentation-JJ.pdf

Another alternative to solve producer mobility is the usage of rendezvous services or
points (RPs) [3]. A RP can be used to help consumer interests get to mobile producers
in one of two ways: the RP can redirect interests from consumers to a mobile producer (chasing)
or the RP can store data procured by the MP as a data depot (storing). Chasing can be done
in several ways, either by using hints provided by the RP (as described above) or by
leaving traces to the MP in FIBs or PITs between the RP and MP. Regardless of what's done, the
key point is that NDN and CCN names are insufficient in handling mobility, and that's a problem.
While the projects are well intentioned in that they try to separate naming from addressing,
practical problems such as mobility force these two to be intertwined again. 

[3]https://www.ietf.org/proceedings/interim/2016/01/14/icnrg/slides/slides-interim-2016-icnrg-1-1.pdf
[] http://profsandhu.com/zhang/pub/icc12-ndn-mobility.pdf
[]http://rd.springer.com/chapter/10.1007%2F978-3-540-24643-5_6

MobilityFirst, a different future Internet architecture, effectively separates naming from addressing
by using GUIDs to identify content. This idea is based on LISP (Location/Identifier Separation Protocol) [4].

TODO: explain LISP!

MobilityFirst [1] supports two types of routing protocols -- routing based on GUIDs and network addresses. 
And even though these are treated separately, MobilityFirst provides a mapping between the two. A
Name Assignment Service is responsible for assigning public keys used to build GUIDs based on these 
keys and a unique sequence number. GUIDs are mapped to all locations in the network where the actual
content can reside. A Global Name Resolution Service is used to map GUIDs to the nearest possible
location, and the network supports routing on the result. Thus, in a way, this hybrid routing
scheme resembles that of NDN with hints. 

[1] TODO: MOBILIY FIRST reference
[4] https://tools.ietf.org/html/rfc6830

## Issues of Scope with Temporal and Immutable Bindings

Let's move away from the routing and mobility issues that are rooted in naming
and turn our attention to the semantics of names themselves. A name is a binding
between one representation of something to some resource. More often than not, this binding
changes in time. For example, in imperative programming langauges, the names of 
mutable variables remain static but the underlying data changes with regularity. 
For example, consider the following imperative for loop.

```
for (int i = 0; i < 5; i++) { 
    System.out.println(names[i]); 
}
```

During every iteration of the loop, the name ```i``` is bound to a different value. 
This type of temporal binding certainly has its use, but we're now living in a world
that is increasingly dominated by multithreaded, multicore, and distributed computations
where immutability is the key to stable and performant systems. Immutability
has crept its way into nearly every layer of the computation stack, from the lower
FS layers with immutable files to the application layer with append-only logs and 
application-generated data sets [helland]. In that same article, Helland gives
examples of how names may be rebound to point to different immutable blocks. In this way,
the binding between a name and data can change even though the underlying data itself
is static. This seems problematic to me. Generally speaking, data is accessed via a name
of some sort, be it a CCN interest name, variable name, pointer address, or HD block number.
If the name for some data is not available, or the name has been rebound to a different piece
of data, how can the data be accessed? Or, as Pat Helland put it, if the binding from some
name and the underlying data changes, can we still consider the data to be immutable [helland]?

This is a difficult question to answer. In order to do so, consider the following.
We typically represent a naming scheme as an injective function
where the domain is the set of names and the range is the set of values that are "alive" or "accessable." 
As bindings change, it may be the case that there is a data element for which there does not exist
a name that maps to the data. These "nameless data elements" should only occur when those data
items are no longer needed or go out of scope. To be specific, let's revisit the for loop example above.
Within the scope of that for loop, the name *i* is bound to 5 different values: 0, 1, 2, 3, 4. 
After each iteration of the for loop, the previous value to which *i* pointed is no longer neeed --
it's out of scope. In this case, it's okay for that value to be lost to nameless abyss. 

The problem is that the scope of a data item is not always clear or under our control. Consider
the name of some content object in CCN. How does a consumer know the scope of this name? How
does a router know that the binding has changed and should therefore discard its cached copy of
the content? Given a content object which binds the name "/foo/bar/baz" to some data, how does
a router know that it should delete the content object when this binding changes? 

TODO: figure of content changing underneath a given name

Put simply: they can't. CCN does not provide a rich enough naming scheme to express
these the scope of the data it represents. Yes, a producer can specify the "lifetime" of a content
object. But that *does not* necessarily correspond to the lifetime of the data encapsulated
by the content object. The producer is responsible for *tuning the lifetime of a content 
object to the expected lifetime of the binding from the name to the underlying data*.
If the name of the content object instead pointed to a single piece of data and the binding 
did not change, e.g., "/foo/bar/baz/v10," then this is no longer a problem. Consumers would 
ask for a specific version of some content, i.e., some name that is never rebound to
another data item, and would retrieve that for which they asked. But if we go down that route, 
then we are left with another problem. Namely, how does a consumer learn the specific version
of content they are interested in? The naming convention could be one that uses two names for
content: (1) a name that always points to the latest version of some content (i.e., the latest
binding), and (2) a sequence of names that point to predecessor values (until they go out of scope). 
The producer is free to change the bindings at their discretion so long as they ensure that
the lifetime of data in the network matches the rate at which this is updated. This is depicted below.

TODO: sequence of names with head pointing to the latest sequence, and each value has a backwards pointer to prior value

Alternatively, to encode all versions of the data, we could use store the data in a persistent data
structure like a fat tree [x]. This would allow each version to be recorded as the bindings changed
in time without having to worry about scope. 

There's one problem here, though. What about data that changes at sporadic intervals or 
based on events? Breaking news, for example, is just that: new content that arrived unexpectedly. 
If an application (stupidly) decides to name its news data under the name "/bad/news/latest," 
how can a consumer be sure that they have the latest data? A far superior approach would be to 
*not* cache the head of the data but to only cache specific, immutable versions of the data and
then refer to these static data elements via redirection. For example, the data named 
"/bad/news/latest" could always produce a list of names of the latest stories, where these names
are *fixed* identities and do not change over time.

[helland] Helland, Pat. "Immutability changes everything." Queue 13.9 (2015): 40.
[x] fat tree

## Privacy with Service-Centric and Data-Centric Names

As the name implies, CCN is all about naming specific data items and transferring
them around the network. Requests for data express the name in full. However,
these requests are routed based on some subset of the name depending on
how the network routers' FIB entries are configured. Therefore, there must
exist some minimal prefix that is necessary to route an interest from a consumer
to an authoritative producer. The rest of the name, i.e., those components which
are not included in *any* LPM match when indexing into the FIB from the consumer to
the producer, can be elided. Currently, its included in cleartext in order to allow
the producer application to act on them to return the right data. However, this is
not a requirement. To attain some amount of privacy, this suffix should be encrypted
so that eavesdroppers cannot discern what's going on over the link.

Let's assume that we do encrypt the suffixes of a name so that the only
part that's left in the clear is the minimal routable prefix. Is that enough
to ensure privacy? 



TODO: describe the email example... and the question about application namespaces and their privacy implications
:wq






2. in ccn, names are used for routing based on LPM. some minimal prefix is necessary to route an interest to an authoritative producer. the rest can be encrypted using some semantically-secure scheme (plaintext reveals nothing of the ciphertext)
3. the prefix itself can be sufficiently revealing: /edu/uci/ics/cwood/files/pictures/file{1-5}. To reach my machine, one must send prefix up to cwood... it could be easy to deduce what the underlying plaintext is based on knowledge of the prefix. 
4. this is not like IP where an address can tell you what type of content is being served -- a single machine can serve many different applications and content. in CCN, the name is more specific and therefore reveals more (it's kind of like shifting information from the payload to the address), and that has security implications. 
5. if we want to not reveal a lot in the name, then the prefix should be short or the prefix shouldn not be indicative of the content. what is the result? a prefix that identifies a *service* to generate some data, rather than a name that identifies a specific piece of data. 
6. there's a tradeoff though: less specific names mean that the target service must provide more content... more specific names reveal more about the server and the content that's generated. 
7. maybe we need to be looking into differential privacy and PIR -- we shouldn't ignore years of research in these fields.


